#include <iostream>
using std::cout;
using std::endl;
#include <vector>
using std::vector;
#include <fstream>
#include <sstream>
#include <cmath>
#include <stdexcept>

std::string help = "Possible arguments:\n"
    "-i: input file\n"
    "-f: sample rate\n"
    "-l: dct size\n"
    "-a: averaging\n"
    "-s: squareroot\n"
    "-r: include inverse\n";

vector<double> dct(vector<double> &values, bool invert, bool squareroot) {
    // Vector containing either spectral value or signal values
    vector<double> result;

    // Calculate a result vector the same size as the input vector
    for(int i = 0; i < values.size(); i++) {

        // Sum the size of the input window resulting in one result for the DCT
        double temp = 0;
        for(int j = 0; j < values.size(); j++) {
            // Inversion of DCT is pretty much the same.
            if(!invert) {
                temp += values.at(j) * cos((M_PI*i*(2*j+1)) / (values.size()*2));
            } else {
                // Alpha value is applied to inverse DCT inside the sum
                double modifier;
                if (j == 0) {
                    modifier = sqrt(1.0/values.size());
                } else {
                    modifier = sqrt(2.0/values.size());
                }
                temp += modifier *
                        values.at(j) * cos((M_PI*j*(2*i+1)) / (values.size()*2));
            }
        }
        // Alpha value is applied outside the sum for DCT
        if (i == 0 && !invert) {
            temp = temp * sqrt(1.0/values.size());
        } else {
            temp = temp * sqrt(2.0/values.size());
        }
        if(squareroot) {
            result.push_back(fabs(temp));
         } else {
            result.push_back(temp);
        }
    }
    return result;
}

vector<double> calc_avg(const vector<vector<double>>& history,
                             const vector<double>& new_values,
                             size_t avg_amount) {
    vector<double> result(new_values);
    
    // If we don't have enough values yet, use what's there (+ 1 because new values)
    avg_amount = std::min(avg_amount, history.size() + 1);
    
    for (int i = 0; i < avg_amount; i++) {
        const int index = history.size() - 1 - i;
        
        if (index < 0 || index >= history.size()) {
            break;
        }
        
        if (history.at(index).size() != result.size()) {
            // TODO make this an assert
            cout << "ERROR: history and result size mismatch!" << endl;
        }

        for (int j = 0; j < result.size(); j++) {
            result.at(j) += history.at(index).at(j);
        }
    }
    
    for(double& d : result) {
        d /= avg_amount;
    }
    
    return result;
}

void gnuplot_export(const vector<double>& input,
                    const vector<vector<double>>& transformed,
                    const vector<vector<double>>& inverse,
                    int samplerate) {
    int window_num = 0;
    int input_index = 0;
    //TODO: add file output for invese too
    for(const vector<double>& window : transformed) {
        std::ofstream dct_file(std::to_string(window_num) + ".dct");
        dct_file << "# DCT spectrum file generated by Arduino_DCT\n";
        dct_file << "# X Y\n";
        
        int x = 0;
        for(const double d : window) {
            const double x_scaled = x * samplerate / (2.0 * window.size());
            dct_file << x_scaled << " " << d << "\n";
            x++;
        }
        
        std::ofstream signal_file(std::to_string(window_num) + ".signal");
        signal_file << "# Signal file generated by Arduino_DCT\n";
        signal_file << "# X Y\n";
        
        x = 0;
        for(int i = 0; i < window.size(); ++i, ++input_index) {
            const double x_scaled = x * 1.0 / samplerate;
            signal_file << x_scaled << " " << input.at(input_index) << "\n";
            x++;
        }
        
        window_num++;
    }
}

int main(int argc, char *argv[]) {
    if(argc < 2) {
        cout << help << endl;
        return 0;
    }

    int sample_rate = 10000;
    std::string filename;
    int dct_size = 16;
    int averaging = 0;
    std::string format = "own";
    bool inverse = false;
    bool squareroot = false;
    for(int i = 0; i < argc; i++) {
        std::string arg = std::string(argv[i]);
        if(arg == "-i") {
            filename = argv[i+1];
        } else if (arg == "-f") {
            sample_rate = atoi(argv[i+1]);
        } else if (arg == "-l") {
            dct_size = atoi(argv[i+1]);
        } else if (arg == "-h") {
            cout << help << endl;
            return 0;
        } else if (arg == "-a") {
            averaging = atoi(argv[i+1]);
        } else if (arg == "-r") {
            squareroot = atoi(argv[i+1]);
        } else if (arg == "-s") {
            inverse = atoi(argv[i+1]);
        }
    }
    
    if(averaging) {
        cout << "averaging over " << averaging << " values" << endl;
    }

    std::ifstream _file(filename);

    if(!_file.good()) {
        throw std::runtime_error("Could not read input file");
    }
    
    vector<double> input;
    std::string str;
    while (std::getline(_file, str)) {
        input.push_back(atof(str.c_str()));
    }

    vector<double> dct_window;
    vector<vector<double>> transformed;
    vector<vector<double>> inverse_dct;

    for(int i = 0; i < input.size(); ++i) {
        // Read signal values to dct window...
        dct_window.push_back(input.at(i));
        // ...until window size is reached then...
        if (i > 0 && i % dct_size == 0) {
            vector<double> temp = dct(dct_window, false, squareroot);
            vector<double> inv;
            if(inverse) {
                inv = dct(temp, true, squareroot);
            }
            if(averaging && transformed.size() > 1) {
                vector<double> average = calc_avg(transformed, temp, averaging);
                transformed.push_back(average);
                
                // std::cout << "averaged" << std::endl;
                for(int i = 0; i < average.size(); i++) {
                    std::cout << average.at(i) << std::endl;
                }
            } else {
                transformed.push_back(temp);
                if(inverse) {
                    inverse_dct.push_back(inv);
                }
                // std::cout << "not averaged" << std::endl;
                for(int i = 0; i < temp.size(); i++) {
                    std::cout << temp.at(i) << std::endl;
                }
                if(inverse) {
                    std::cout << std::endl;
                    for(int i = 0; i < temp.size(); i++) {
                        std::cout << inv.at(i) << std::endl;
                    }
                    std::cout << std::endl;
                }
            }
            // clear window to fill it with new signal values
            dct_window.clear();
        }
    }


    if(transformed.size() == 0) {
        std::cout << "No results written, is your dct window "
                     "longer than your file?" << std::endl;
    } else {
        gnuplot_export(input, transformed, inverse_dct, sample_rate);
    }
    
    return 0;
}
